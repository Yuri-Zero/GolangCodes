# 函数笔记
## Go语言函数特点
golang的函数有以下几个特点
<ul>
<li>不需要声明原型</li>
<li>支持不定 变参</li>
<li>支持多返回值</li>
<li>支持命名返回参数</li>
<li>支持闭包和匿名函数</li>
<li>不支持嵌套，一个package中不能有两个相同名字的函数</li>
<li>无法重载</li>
<li>不支持默认函数</li>
<li>函数也是一种类型</li>
</ul>

## 函数定义
函数签名包含一个函数名，参数列表， 返回值列表和函数体。其中如果返回值为空则可以省略返回值列表
```go
func 函数名 (参数列表) (返回值列表){
    //函数体
}
```
当返回值只有一个的时候:
```go
func 函数名(参数列表)返回值{
    //函数体
}
```
## 函数调用
函数可以使用函数调用运算符()进行调用,具体格式为:
```go
函数名(参数...)
```
如无参数则为空(),如有返回值的函数则可将函数用于变量赋值
如:
```go
func add(x int, y int) int {
	return x + y
}
func main() {
	x := 10
	y := 10
	z := add(x, y)
	fmt.Println(z)
}
```
## 参数
在函数定义时有参数列表，该列表中的变量被称为函数的形参，可以理解为函数内部的局部变量，但当调用函数，传递过来的变量就是函数的实参，函数可以通过两种方式来传递参数：<br/>
**值传递**：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br/>
**引用传递**：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
## 函数作为类型使用
在golang中，函数可以作为类型使用，如
```go
type subtool func(x int, y int) int

func sub(fn subtool, x int, y int) int {
	return fn(x, y)
}
```
### 匿名函数
Go语言同时支持匿名声明一个函数,你可以随时在代码里定义匿名函数。

匿名函数由一个不带函数名的函数声明和函数体组成。匿名函数的优越性在于可以直接使用函数内的变量，而不必声明。如:
```go
	sub(func(x int, y int) int { return x - y }, x, y)//在这里sub的第一个参数是一个匿名函数
```
### 闭包
闭包=函数+引用环境
```go
func AddUpper() func(x int) int {
	n := 10
	return func(x int) int {
		n = n + x
		return n
	}
}
//MAIN:
	f := AddUpper()
	fmt.Println(f(1))
	fmt.Println(f(2))
```
结果为:
```go
11
13
```
显而易见,n只被初始化了一次。
上面这段代码的详解:
```go
AddUpper是一个函数，它返回的类型是func(x int) int
返回的是一个匿名函数，但是这个匿名函数引用了其外的变量n，于是变量n和返回的匿名函数形成了一个整体，构成闭包。闭包函数私有化了变量n，完成了数据封装。
n只初始化一次
重点:当AddUpper中嵌套了一个匿名函数,而外部变量f引用了AddUpper,实际上引用的是AddUpper里面的匿名函数，这就形成了一个闭包，其中AddUpper的内部资源不会被GC回收。
可以把AddUpper理解为类,n为字段,匿名函数为方法
```
